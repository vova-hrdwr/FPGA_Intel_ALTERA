In this project we have two counters: a fast counter and a slow counter, along with a comparator. Each time the outputs of the slow and fast counters are equal, the slow counter increases and the fast counter loading zero. Uploading The SV code here:
----------------------------------------------------------------------Counter--------------------------------------------------------------------------
// loadN, enable_cnt and enable to control the count
// and data input - init[3:0] for the load functionality

module up_counter 
	(
   // Input, Output Ports
   input logic clk, 
   input logic resetN,
   input logic enable,
	input logic loadN,
   input logic enable_cnt,
   input logic [3:0] init,
   output logic [3:0] count 
   );

//------------------------------------------------------------------------------------	
   always_ff @( posedge clk or negedge resetN )
   begin	
     
		if ( !resetN ) begin	// Asynchronic reset
		 count <= 4'b0000;
		 end
		else if (enable) begin
		   if (!loadN)
			   count <= init;
			else if (enable_cnt)
			   count <= count + 4'b0001;
		end
	else count <= count;	
		
	end // always
//-------------------------------------------------------------------------------------
endmodule
----------------------------------------------------------------------Comparator--------------------------------------------------------------------------
// Implements a simple equality one-bit out comparator
module comparator 
	(
   // Input, Output Ports
	input logic [3:0] vect1,
	input logic [3:0] vect2,
	output logic cmp
   );	
//------------------------------------------------------------------------------------
always_comb begin
  if (vect1 == vect2)
     cmp = 1'b1;
  else
     cmp = 1'b0;
end	  
//-------------------------------------------------------------------------------------	
endmodule
----------------------------------------------------------------------Inflating Counter--------------------------------------------------------------------------
// Implements the inflating counter by instantiating
// two counters and a comparator

module inflating_counter 
	(
   // Input, Output Ports
	input logic clk, 
	input logic resetN, 
	input logic enable,
   
	output logic [3:0] FastCount,
	output logic [3:0] SlowCount
   );


	logic enable_cnt; // internal variable - output of the comparator	
//------------------------------------------------------------------------------------
	
	// Fast counter instantiation
	up_counter fastC(
				.clk(clk), .resetN(resetN), .enable(enable), .loadN(!enable_cnt), .enable_cnt(1'b1), .init(4'b0000), .count(FastCount) 
				);

	// Slow counter instantiation
	up_counter slowC(.clk(clk), .resetN(resetN), .enable(enable), .loadN(1'b1), .enable_cnt(enable_cnt), .init(4'b0000), .count(SlowCount) 
				);	
				
	
	// Comparator instantiation
   comparator cmp 
	(.vect1(FastCount), .vect2(SlowCount), .cmp(enable_cnt)
   ); 
	
//-------------------------------------------------------------------------------------

endmodule
----------------------------------------------------------------------hexSS--------------------------------------------------------------------------
// Implements the hexadecimal to 7Segment conversion unit
// by using a two-dimensional array

module hexss 
	(
	input logic [3:0] hexin, // Data input: hex numbers 0 to f
	input logic darkN, 
	input logic LampTest, 	// Aditional inputs
	output logic [6:0] ss 	// Output for 7Seg display
	);
	
//------------------------------------------------------------------------------------

// Declaration of two-dimensional array that holds the 7seg codes
   logic [0:15] [6:0] Seven_Seg = {7'b1000000, 7'b1111001, 7'b0100100,
	7'b0110000, 7'b0011001, 7'b0010010, 7'b1000010, 7'b1111000, 7'b0000000,
	7'b0010000, 7'b0001000, 7'b0000011, 7'b1000110, 7'b0100001, 7'b0000110,
	7'b0001110};
		
  always_comb begin
    if (darkN == 1 && LampTest == 0)
        ss = Seven_Seg[hexin];
    else if (darkN == 1 && LampTest == 1)
        ss = 7'b0000000;
    else if (darkN == 0)
        ss = 7'b1111111;
    else
        ss = 7'bxxxxxxx; 
  end
	    
//-------------------------------------------------------------------------------------

endmodule
